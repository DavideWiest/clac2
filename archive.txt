interpreter: 

let buildArgs evalCtx (argsBefore: DefinedValue array) (signature: FnType array) : FullClacResult<DefinedValue array> =
        if argsBefore.Length = signature.Length - 1 then argsBefore |> Ok else
        
        argsBefore[signature.Length - 2]
        |> definedValueFnToReference evalCtx
        |> bind (fun startFn -> eval evalCtx startFn argsBefore[signature.Length - 1..])
        |> map (fun lastArg -> Array.concat [argsBefore[0..signature.Length - 3]; [| lastArg |]])

middle end: checkManipulation

            // prevent Array.last from throwing exception
            if inputSignature.Length = 0 then Some (IntermediateExcFPPure ("Too many arguments for function " + f) line) else

            // check the other types
            let typesUntilLastMatch = typesMatch inputSignature[..inputSignature.Length-2] typesOfArgs[..typesOfArgs.Length-2] f
            if typesUntilLastMatch |> Option.isSome then typesUntilLastMatch |> Option.map (IntermediateExcMaybeLine line) else

            // if too many arguments exist, try to pass them into the last argument
            let lastArg = args |> Array.last

            match lastArg with
            | Fn f' -> 
                let lastInputType = inputSignature |> Array.last
                let outputSignature' = functionSignatureMap[f'] |> Array.last

                if lastInputType <> outputSignature' then Some(IntermediateExcFPPure (sprintf "Argument type mismatch: Expected %A, but got %A. Trying to push superfluous arguments of function %s to last element." lastInputType outputSignature' f) line) else

                checkManipulation customFnsMap functionSignatureMap m[inputSignature.Length..]

middle end: entry Fn

        let customFnsMap = 
            program.secondaryFiles
            |> Array.map (fun f -> f.content.assignments)
            |> Array.concat
            |> Array.append file.assignments
            |> Array.map (fun x -> x.name, x) 
            |> Map.ofArray

middle end: checkManipulation match m[0] with Fn ...

            let innerManipCorrect = checkManipulation typeCheckingCtx m' line
            if innerManipCorrect.IsSome then innerManipCorrect else
            if m.Length = 1 then None else
            
            // match signature
            match ReferenceToFnType typeCheckingCtx line m'[0] with
            | Error e -> Some (e)
            | Ok(Function fs) -> 
                let remainingSignature = fs[..fs.Length-2]

                if remainingSignature.Length <> m.Length - 1 then Some (IntermediateExcFPPure ("Invalid number of arguments for: " + (manipulationToString m')) line) else
                
                typesMatch remainingSignature m[1..] f line |> Option.map (IntermediateExc line)
            | Ok(BaseFnType t) -> Some (IntermediateExcFPPure ("Function " + (manipulationToString m') + " received too many arguments.") line)

middle end:

    let ReferenceToFnType (typeCheckingCtx: TypeCheckingCtx) line (x: Reference) : IntermediateClacResult<FnType> =
        // variables are treated as functions in the reference type, but not in the fntype type
        let returnSig (s: Signature) = if s.Length = 1 then Ok s[0] else Ok (Function s)

        match x with
        | Fn f -> 
            if isPrimitive f then Ok (getValidatedPrimitiveType f) else
            returnSig typeCheckingCtx.signatures[f]
        | Manipulation m ->
            match checkManipulation typeCheckingCtx m line with
            | Some e -> Error e
            | None -> ReferenceToFnType typeCheckingCtx line m[0]

middle end old typesmatch:

        let rec typesMatch (inputSignature: FnType array) args f : IntermediateException option =
            Array.fold (fun acc (signaturePart: FnType, arg) -> 
                acc
                |> Option.orElse (
                    match arg with
                    | Fn f' ->
                        if isPrimitive f' then 
                            // check is primitive type matches signaturepart
                        else
                        let argSignature = Signature.retrieve typeCheckingCtx f'
                        if Signature.signaturesMatch signaturePart (Function argSignature) then None else Some (IntermediateExcFPPure (sprintf "Argument type mismatch: Expected %A, received %A for function %s." signaturePart argSignature f) line) 
                    // fix this: it leads to infinite recursion
                    | Manipulation m' -> 
                    
                        if m'.Length = 1 
                        then if m'.[0] =  then None else Some (IntermediateExcFPPure (sprintf "Argument type mismatch: Expected %A, received %A." signaturePart m'.[0]) line)
                        else checkManipulation typeCheckingCtx m' line (ExpectedType signaturePart)
                        //match signaturePart with
                        //| BaseFnType s ->
                        //    // fix this 
                        //    // factorial (subtract (n 1)) does not work
                        //    // mabe a recursive call?
                        //    // constants/variables are treated as functions with no arguments
                        //    if m'.Length <> 1 then Some (IntermediateExcFPPure ("Expected constant (function without arguments), but received function.") line) else
                        //    if m'[0] <> Fn s then Some (IntermediateExcFPPure (sprintf "Expected constant of type %s, received %A." s m'[0]) line) else 
                        //    None
                        //| Function fs -> 
                        //    checkManipulation typeCheckingCtx m' line (ExpectedType signaturePart) 
                        //    |> Option.orElse(typesMatch fs m' f)
                )
            ) None (Array.zip inputSignature args)

middle end, signatures:

        let rec signaturesMatch (expected: FnType) (actual: FnType) =
            match expected, actual with
            | BaseFnType s1, BaseFnType s2 -> s1 = s2
            | Function fs1, Function fs2 -> fs1 |> Array.zip fs2 |> Array.forall (fun (a, b) -> signaturesMatch a b)
            | Function fs1, BaseFnType _ -> fs1.Length = 1 && signaturesMatch fs1.[0] actual
            | BaseFnType _, Function fs2 -> fs2.Length = 1 && signaturesMatch expected fs2.[0]

interpreter: eval case of manipulation as startFn:

printfn "--- eval manipulation %A with %A ---" m args

        evaluateOne evalCtx (EvalCtx.getCurrentLoc evalCtx) m Map.empty
        |> bind (fun newStartFnValue -> 
            match newStartFnValue with 
            | DefinedFn (name, fn) -> 
                let newStartFn = DefinedStartFn (name, fn)
                eval evalCtx newStartFn args
            | DefinedPrimitive p -> EvalCtx.FullExcFromEvalCtx ("Primitive " + p.ToString() + " used as function.") evalCtx
        ) 